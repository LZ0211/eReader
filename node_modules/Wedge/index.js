"use strict";
const 
    fs = require("fs"),
    Path = require("path"),
    os = require("os"),
    URL = require("url"),
    querystring = require("querystring"),
    EventEmitter = require("events"),
    child_process = require("child_process"),
    readline = require("readline"),
    Random = require("JSrandom"),
    decoder = require("iconv-lite"),
    Log = require("Wedge-Log"),
    Hash = require("Wedge-Hash"),
    DataBase = require("Wedge-DataBase"),
    Request = require("Wedge-request"),
    Thread = require("Wedge-Thread"),
    Cache = require("Wedge-Cache"),
    Parser = require("Wedge-Parser"),
    Classes = require("Wedge-Classes"),
    Book = require('Wedge-Book'),
    Sites = require("Sites"),
    util = require("../util"),
    Searcher = require("./searcher")

let setting = require("./setting")
let cache = new Cache(8*1024*1024)

function noop(){}
function pipe(data){return data}

function prompt(docs,fn){
    if(!Array.isArray(docs)){
        docs = [docs]
    }
    let 
        rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        }),
        args = [],
        len = Math.max(docs.length,fn.length),
        ref = 0;

    if (len === 0){
        rl.close()
        return fn.apply(null,args)
    }
    function listen(){
        rl.question(docs[ref],function(input){
            args.push(input)
            ref += 1
            if(ref === len){
                rl.close()
                return fn.apply(null,args)
            }else{
                return listen()
            }
        })
    }
    listen()
}

function request(options){
    options.url = options.url || options.href || options.src
    options.method = options.method || options.type || 'GET'
    options.timeout = setting.get('request.timeout')
    options.reconnect = setting.get('request.reconnect')
    options.proxy = setting.get('request.proxy')
    options.proxyAuth = setting.get('request.proxyAuth')
    options.success = options.success || pipe
    options.error = options.error || (err=> Promise.reject(err))

    if (options.method === 'GET'){
        let data = cache.get(options.url)
        if (data) return Promise.resolve(data).then(options.success)
    }

    let req = new Request.Request(options.url, options.method)
    options.timeout && req.timeout(options.timeout)
    options.reconnect && req.reconnect(options.reconnect)
    options.proxy && req.proxy(options.proxy)
    options.proxyAuth && req.proxyAuth(options.proxyAuth)
    options.dataType && req.accept(options.dataType)
    options.data && options.method === 'POST' && req.send(options.data)
    options.contentType && req.type(options.contentType)
    options.headers && req.setHeader(options.headers)

    let connectTimes = 0
    let maxConnectTimes = options.reconnect

    return new Promise((resolve,reject)=>{
        req.end((err,res,data)=>{
            connectTimes += 1
            if (res && /^20.$/.test(res.statusCode)){
                if (options.method === 'GET'){
                    cache.set(options.url,data)
                }
                return resolve(data)
            }
            if (err){
                if (connectTimes < maxConnectTimes){
                    setTimeout(req.end.bind(req),Math.pow(2,connectTimes)*500)
                    return
                }else{
                    return reject(err)
                }
            }
            return reject(res.statusCode)
        })
    }).then(options.success,options.error)
}

function decodeData(data,url){
    let site = Sites.search(url)
    let $ = Parser(data,url,site.charset)
    let cookies = querystring.parse(request.cookies.getCookie(url),'; ')
    $.getCookie = name=>(cookies[name]||'')
    $.encode = util.encode
    $.decode = util.decode
    $.replace = util.replace
    $.site = site
    return $
}

const logFuns = [
    noop,
    console.log.bind(console),
    Log('app.log')
]

class Project extends EventEmitter{
    constructor(){
        super()
        this.label = Random.uuid(8,16)
        this.bookMeta = {}
        this.bookdir = null
        this.infoPage = null
        this.indexPage = null
        this.chapterList = []
        this.infoPageFailTimes = 0
        this.iindexPageFailTimes = 0
        this.chapterPageFailTimes = 0
        this.imageFailTimes = 0
    }

    toString(){
        return JSON.stringify({
            bookdir:this.bookdir,
            infoPage:this.infoPage,
            indexPage:this.indexPage,
            chapterList:this.chapterList
        })
    }

    setInfoPage(url){
        this.infoPage = url
        return this
    }

    setIndexPage(url){
        this.indexPage = url
    }

    addIndexPage(url){
        if(!Array.isArray(url)){
            this.indexPage = [this.indexPage]
        }
        this.indexPage.push(url)
    }

    loadFrom(dir){
         
    }

    getParsedData($){
        let filter = util.object.filter,
            map = util.object.map,
            site = $.site,
            rule = filter(site.selector,(k,v)=>v.match($) && (v.footer($) || /<\/html>/i.test($.raw))),
            apply = (k,v)=>(util.is.isFunction(v) ? v($) : map(v,apply)),
            replace = (data,rule)=>map(data,(k,v)=>{
                if(!rule[k]) return v
                if(util.is.isObject(v)){
                    if(util.is.isObject(rule[k])) return replace(v,rule[k])
                    return v
                }
                return util.replace(v,rule[k])
            })

        return replace(map(rule,apply),site.replacer)
    }
    
    getBookMeta(){
        let url = this.infoPage
        if(!url) throw new Error('No bookinfopage url')
        
        return fetch(url).then(data=>decodeData(data,url)).then(this.getParsedData)
    }
}

class Wedge extends EventEmitter{
    constructor(libraryDir){
        super()
        //load default setting and database
        this.config = new Hash(setting)
        this.database = DataBase()
        //change work directory
        this.chdir(libraryDir)
        //init application
        this.init()
        return this
    }

    pipe(data,fn){
        if(typeof fn !== 'function'){
            fn = noop
        }
        fn(data)
        return data
    }

    chdir(dir){
        //if no dir input ,use default library directory of '{user}/Documents/Wedge-Library'
        dir = dir || Path.join(os.homedir(),'Documents','Wedge-Library')
        this.dir = Path.resolve(dir)
        //create library folder if need
        fs.mkdirsSync(this.dir)
        process.chdir(this.dir)
        return this
    }

    init(){
        this.initConfig()
        this.initDatabase()
        this.initLog()
        this.initDebug()
        this.initThread()
    }

    initConfig(){
        //localization app config to file setting.config
        this.config.file('setting.config')
        setting = this.config
        //change the log function if config.app.log changed
        this.config.on('app.log',this.initLog.bind(this))
        //change the debug function if config.app.log changed
        this.config.on('app.debug',this.initDebug.bind(this))
        //change the databse file or state
        this.config.on('database',this.initDatabase.bind(this))
        return this
    }

    initDatabase(){
        //load database from metadatas.sqlite
        this.database.file(Path.join(this.dir,'metadatas.sqlite'))
        /*set the sync state
        if true the database will auto localization when the database has any change
        otherwise the database will localization only when exit or call close or closeSync function
        */
        this.database.sync(this.config.get('database.sync'))
        return this
    }

    initLog(){
        this.log = logFuns[this.config.get('app.log')]
        return this
    }

    initDebug(){
        this.debug = logFuns[this.config.get('app.debug')]
        return this
    }

    initPlugins(){
        let plugins = this.config.get('plugins')
        for(let plugin in plugins){
            let pluginDefine = plugins[plugin]
            if(pluginDefine.activated){
                this[plugin] = require(pluginDefine.func).call(this)
            }
        }
        return this
    }

    initThread(){
        this.updateThread = Thread().end(()=>this.emit('updateThreadEnd')).use(this.update)
        this.addThread = Thread().end(()=>this.emit('addThreadEnd')).use(this.add)
        this.refreshThread = Thread().end(()=>this.emit('refreshThreadEnd')).use(this.refresh)
        this.ebookThread = Thread().end(()=>this.emit('refreshThreadEnd')).use(this.ebook)
        this.config.on('thread.update',()=>this.updateThread.threads(this.config.get('thread.update')))
        this.config.on('thread.add',()=>this.updateThread.threads(this.config.get('thread.add')))
        this.config.on('thread.refresh',()=>this.updateThread.threads(this.config.get('thread.refresh')))
        this.config.on('thread.ebook',()=>this.updateThread.threads(this.config.get('thread.ebook')))
        return this
    }

    getUpdateThreadInfo(fn){
        return this.updateThread.info()
    }

    getAddThreadInfo(fn){
        return this.addThread.info()
    }

    getRefreshThreadInfo(fn){
        return this.refreshThread.info()
    }

    getEbookThreadInfo(fn){
        return this.ebookThread.info()
    }

    add(url){
        let project = new Project()
        project.startFrom(url)
        return project
    }

    update(uuid){

    }

    refresh(uuid){

    }

    ebook(uuid){

    }

    multiAdd(...urls){
        this.addThread.queue(urls).start()
        return this
    }

    multiUpdate(...uuids){
        this.updateThread.queue(uuids).start()
        return this
    }

    multiRefresh(...uuids){
        this.refreshThread.queue(uuids).start()
        return this
    }

    multiEbook(...uuid){
        this.ebookThread.queue(uuids).start()
        return this
    }

    prompt(docs,fn){
        prompt(docs,fn)
        return this
    }

    searchInSite(title,site){
        if(!site || !site.url) return Promise.resolve([]);
        let
            links = [],
            push = link=>links.push(link)

        let url = site.url
            .replace('%title%',util.encodeURI(title,site.charset))
            .replace('%time%',+new Date())
            .replace('%random%',Math.random())

        let query = (site.query || '')
            .replace('%title%',util.encodeURI(title,site.charset))
            .replace('%time%',+new Date())
            .replace('%random%',Math.random())

        let method = (site.method || 'GET').toUpperCase()
        let data = site.data && site.data.replace('%title%',title)
        let success = data=>{
            if(site.parse){
                var parser = new Function('json','try{return (' + site.parse + ')}catch(e){return []}');
                parser(data).forEach(push);
            }else {
                var $ = Parser(data,url);
                var selector = site.selector || ':header a,img a';
                $(selector).filter((i,v)=>~$(v).text().indexOf(title)).each((i,v)=>links.push([
                    $.location($(v).attr('href')),
                    $(v).text().trim()
                ]));
            }
            if(site.engine){
                return new Promise((resolve,reject)=>{
                    Thread().queue(links).use((link,next)=>{
                        fetch(link[0]+'&wd=').then(data=>{
                            let $ = Parser(data,link[0])
                            let content = $('meta[http-equiv="refresh"]').attr('content')
                            if(!content) return next()
                            link[0] = content.replace(/0;URL='(.*)'/,'$1')
                            link[1] = link[1].replace(/_.*/,'')
                            return next()
                        },next)
                    }).threads(10)
                    .end(()=>resolve(links))
                    .start()
                })
            }
            return links;
        }
        let filter = links=>{
            if(site.filter){
                let regexp = new RegExp(site.filter)
                links = links.filter(link=>regexp.test(link[0]))
            }else{
                links = links.filter(link=>~link[0].indexOf(site.name))
            }
            return links;
        }
        let options = {
            url:url+'?'+query,
            method:method,
            data:data && util.encode(data,site.charset),
            dataType:site.dataType,
            headers:site.headers
        };
        if(site.parse){
            options.headers = {
                'X-Requested-With':'XMLHttpRequest'
            };
        }
        if(site.headers){
            for(var name in site.headers){
                if('string' == typeof site.headers[name]){
                    site.headers[name] = site.headers[name].replace('%title%',util.encodeURI(title,site.charset)).replace('%time%',+new Date()).replace('%random%',Math.random());
                }
            }
        }
        return fetch(options).then(success).then(filter)
    }

    fuzzysearchBook(title){
        let links = [],
            push = link=>links.push(link),
            search = (site,next)=>this.searchInSite(title,site).then(list=>{
                list.forEach(push)
                return next()
            })
        return new Promise((resolve,reject)=>{
            Thread().use(search)
            .queue(Searcher)
            .end(()=>resolve(links))
            .threads(3)
            .log(this.debug)
            .label('fuzzysearchBook')
            .start()
        })
    }

    getParsedData(data,url){
        let site = Sites.search(url),
            $ = Parser(data,url,site.charset),
            cookies = querystring.parse(request.cookies.getCookie(url),'; '),
            filter = util.object.filter,
            map = util.object.map,
            rule = filter(site.selector,(k,v)=>v.match($) && (v.footer($) || /<\/html>/i.test($.raw))),
            apply = (k,v)=>(util.is.isFunction(v) ? v($) : map(v,apply)),
            replace = (data,rule)=>map(data,(k,v)=>{
                if(!rule[k]) return v;
                if(util.is.isObject(v)){
                    if(util.is.isObject(rule[k])) return replace(v,rule[k]);
                    return v;
                }
                return util.replace(v,rule[k]);
            })

        $.getCookie = name=>(cookies[name]||'');
        $.encode = util.encode;
        $.decode = util.decode;
        $.replace = util.replace;
        return replace(map(rule,apply),site.replacer);
    }

    Project(){}
}


var app = new Wedge()

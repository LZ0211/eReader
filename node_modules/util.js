const fs = require("fs")
const path = require("path")
const decoder = require("iconv-lite")

function noop(){}

fs.mkdirsSync = function (dir){
    if (fs.existsSync(dir)) return
    let dirname = path.dirname(dir)
    fs.existsSync(dirname) || fs.mkdirsSync(dirname)
    fs.mkdirSync(dir)
}

fs.rmdirsSync = function (root){
    if (!fs.existsSync(root)) return
    let filestat = fs.statSync(root)
    if (filestat.isDirectory() == true){
        let files = fs.readdirSync(root)
        files.forEach(function (file){
            fs.rmdirsSync(path.join(root,file))
        })
        fs.rmdirSync(root)
    }else {
        fs.unlinkSync(root)
    }
}


function clone(object){
    if (Array.isArray(object)){
        return object.concat();
    }
    if (typeof object === "object"){
        var _object = {};
        for (var k in object){
            if (object.hasOwnProperty(k)){
                _object[k] = object[k];
            }
        }
        return _object;
    }
    else {
        return object;
    }
}

function cloneDeep(object){
    if (Array.isArray(object)){
        return object.map(k=>cloneDeep(k));
    }
    if (typeof object === "object"){
        var _object = {};
        for (var k in object){
            if (object.hasOwnProperty(k)){
                _object[k] = cloneDeep(object[k]);
            }
        }
        return _object;
    }
    else {
        return object;
    }
}

function toArray(arrayLike){
    var arr = [];
    [].slice.call(arrayLike).forEach(function (item){
        if (Array.isArray(item)){
            item.forEach(arguments.callee);
        }else {
            arr.push(item);
        }
    });
    return arr;
}

function range(template,start,end){
    return Array(end-start+1).fill(start).map((x,y)=>x+y).map(x=>template.replace(/\*/g,x));
}

function encodeBase64(str){
    return Buffer.from(str).toString('base64');
}

function decodeBase64(str){
    return Buffer.from(str,'base64').toString();
}

function loadJSON(dir){
    return JSON.parse(fs.readFileSync(dir).toString());
}

function each(object,fn){
    for (var k in object){
        fn.call(object,k,object[k],object);
    }
}

function map(object,fn){
    var oo = {};
    for (var k in object){
        oo[k] = fn.call(object,k,object[k],object);
    }
    return oo;
}

function filter(object,fn){
    var oo = {};
    for (var k in object){
        if (fn.call(object,k,object[k],object)){
            oo[k] = object[k];
        }
    }
    return oo;
}

var toString = Object.prototype.toString;
function isRegExp(value){
    return toString.call(value) === "[object RegExp]";
}

function isObject(value){
    return toString.call(value) === "[object Object]";
}

function isFunction(value){
    return toString.call(value) === "[object Function]";
}

function isString(value){
    return toString.call(value) === "[object String]";
}
function toReStr(str) {
    return str.replace(/[()\[\]{}|+.,^$?\\*]/g, "\\$&");
}
function replace(value,selector){
    if(!value) return value;
    if (isFunction(selector)){
        value = selector(value);
        return value;
    }
    if (isString(selector)){
        var regexp;
        try{
            regexp = new RegExp(selector,"gi");
        }catch (e){
            regexp = new RegExp(toReStr(selector),"gi");
        }
        return replace(value,regexp);
    }
    if (Array.isArray(selector)){
        selector.forEach(x=>{
            value = replace(value,x);
        });
        return value;
    }
    if (isRegExp(selector)){
        value = value.replace(selector,"");
        return value;
    }
    if (isObject(selector)){
        Object.keys(selector).forEach(function (k){
            try{
                var regexp = new RegExp(k,"gi");
            }catch (e){
                var regexp = new RegExp(toReStr(k),"gi");
            }
            value = value.replace(regexp,selector[k]);
        });
        return value;
    }
    return value;
}

function encodeURI(str,charset){
    switch(charset){
        case undefined:
            return encodeURIComponent(str)
        case 'unicode':
            return str.split('').map(x=>'%u'+x.charCodeAt().toString(16).toUpperCase()).join('')
        case 'base64':
            return encodeBase64(str)
        default:
            return [].map.call(decoder.encode(str,charset),value=>'%'+value.toString(16).toUpperCase()).join('')
    }
}

function decodeURI(str,charset){
    switch(charset){
        case undefined:
            return decodeURIComponent(str)
        case 'unicode':
            return str.split('%u').slice(1).map(x=>String.fromCharCode(parseInt(x,16))).join('')
        case 'base64':
            return decodeBase64(str)
        default:
            return decoder.decode(Buffer.from(str.split('%').slice(1).map(x=>parseInt(x,16))),charset)
    }
}

function encode(str,charset){
    switch(charset){
        case undefined:
            return Buffer.from(str)
        case 'unicode':
            return str.split('').map(x=>'\\u'+x.charCodeAt().toString(16).toUpperCase()).join('')
        case 'base64':
            return encodeBase64(str)
        case 'html':
            return str.split('').map(x=>'&#'+x.charCodeAt().toString()+';').join('')
        default:
            return decoder.encode(str,charset)
    }
}

function decode(str,charset){
    switch(charset){
        case undefined:
            return str.toString()
        case 'unicode':
            return str.split('\\u').slice(1).map(x=>String.fromCharCode(parseInt(x,16))).join('')
        case 'base64':
            return decodeBase64(str)
        case 'html':
            return str.replace(/&#(x)?([^&]{1,5});?/ig,($, $1, $2)=>String.fromCharCode(parseInt($2, $1 ? 16 : 10)))
        default:
            return decoder.decode(str,charset)
    }
}

function formatLink(link){
    if (typeof link === "string"){
        return {url:link};
    }
    link.url = link.href || link.url || link.src || link.source;
    link.method = (link.method || "GET").toUpperCase();
    return link;
}
 

module.exports = {
    encodeURI:encodeURI,
    decodeURI:decodeURI,
    encode:encode,
    decode:decode,
    formatLink:formatLink,
    replace:replace,
    clone:clone,
    cloneDeep:cloneDeep,
    toArray:toArray,
    range:range,
    encodeBase64:encodeBase64,
    decodeBase64:decodeBase64,
    loadJSON:loadJSON,
    object:{
        each:each,
        map:map,
        filter:filter
    },
    is:{
        isFunction:isFunction,
        isRegExp:isRegExp,
        isObject:isObject,
        isString:isString,
    }
};